<script>
    // =============================
    //   CONFIGURAR SUPABASE
    // ... (sin cambios)
    // =============================
    const SUPABASE_URL = "https://jwcgiuhdugjunndfpdjr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imp3Y2dpdWhkdWdqdW5uZGZwZGpyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5NTA2NTQsImV4cCI6MjA3ODUyNjY1NH0.llknOTpK1hFMDOjdyDUKUFuiyr0NwwJzNv6YdJbBsRY";

    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // Variable global para mantener la lista actual de IDs en cada contenedor
    let currentPendingIds = [];
    let currentEntregadaIds = [];

    // =============================
    //   EJECUTAR CUANDO DOM ESTÉ LISTO
    // =============================
    document.addEventListener("DOMContentLoaded", () => {

        // =============================
        //   CREAR TARJETAS
        // ... (sin cambios)
        // =============================
        function crearCardPendiente(s, materiales) {
            const materialesHTML = materiales.map(m => `<li>${m.material} — ${m.cantidad} ud</li>`).join("");
            // Nota: Se ha añadido el ID `solicitud_${s.id}` a las tarjetas para poder identificarlas
            return `
              <div id="solicitud_${s.id}" class="p-4 bg-gray-50 border rounded-lg shadow-sm">
                <p class="text-sm text-gray-600"><strong>ID:</strong> ${s.id}</p>
                <p><strong>Docente:</strong> ${s.docente}</p>
                <p><strong>Asignatura:</strong> ${s.asignatura}</p>

                <p class="mt-2 font-semibold">Materiales:</p>
                <ul class="ml-4 list-disc text-sm">${materialesHTML}</ul>
              </div>
            `;
        }

        function crearCardEntregada(s, materiales) {
            const materialesHTML = materiales.map(m => `<li>${m.material} — ${m.cantidad} ud</li>`).join("");
            return `
              <div id="solicitud_${s.id}" class="p-4 bg-gray-50 border rounded-lg shadow-sm">
                <p class="text-sm text-gray-600"><strong>ID:</strong> ${s.id}</p>
                <p><strong>Docente:</strong> ${s.docente}</p>
                <p><strong>Asignatura:</strong> ${s.asignatura}</p>

                <p class="mt-2 font-semibold">Materiales:</p>
                <ul class="ml-4 list-disc text-sm">${materialesHTML}</ul>

                <div class="mt-3">
                  <textarea id="coment_${s.id}" class="w-full p-2 border rounded-lg text-sm" placeholder="Escribe un comentario..."></textarea>
                  <div class="flex gap-2 mt-2">
                    <button onclick="guardarComentario(${s.id})"
                      class="px-3 py-1 bg-green-600 text-white rounded-lg text-sm hover:bg-green-700">
                      Enviar comentario
                    </button>
                    <button onclick="guardarSinComentario(${s.id})"
                      class="px-3 py-1 bg-gray-500 text-white rounded-lg text-sm hover:bg-gray-600">
                      Sin comentario
                    </button>
                  </div>
                </div>
              </div>
            `;
        }

        // =============================
        //   CARGAR LISTAS
        // =============================

        // --- Función auxiliar para insertar/remover elementos sin reemplazar el contenedor ---
        function actualizarContenedor(contenedorId, nuevasSolicitudes, creadorCardFn, currentIdsArray) {
            const cont = document.getElementById(contenedorId);
            const nuevosIds = nuevasSolicitudes.map(s => s.id);

            // 1. Eliminar tarjetas que ya no están en la lista (fueron completadas o movidas)
            cont.querySelectorAll(":scope > div").forEach(card => {
                const id = parseInt(card.id.replace("solicitud_", ""));
                if (!nuevosIds.includes(id)) {
                    card.remove();
                }
            });

            // 2. Insertar o mover tarjetas nuevas/existentes
            const fragment = document.createDocumentFragment();
            nuevasSolicitudes.forEach(s => {
                let card = document.getElementById(`solicitud_${s.id}`);
                
                // Si la tarjeta NO existe, la creamos
                if (!card) {
                    const temp = document.createElement('div');
                    // Usamos insertAdjacentHTML para que el HTML se convierta en nodos DOM
                    temp.innerHTML = creadorCardFn(s, s.materiales);
                    card = temp.firstChild; 
                }
                
                // Agregamos la tarjeta (nueva o existente) al fragmento, 
                // manteniendo el orden de las nuevas solicitudes.
                fragment.appendChild(card);
            });

            // 3. Reemplazar el contenido completo del contenedor con el fragmento
            // Esto asegura que el orden es correcto, pero reusa los nodos existentes
            // que estaban siendo editados (sin borrar el contenido de los textarea).
            cont.innerHTML = '';
            cont.appendChild(fragment);

            // 4. Actualizar la lista de IDs actuales (para seguimiento)
            if (contenedorId === 'listaPendientes') {
                currentPendingIds = nuevosIds;
            } else if (contenedorId === 'listaEntregadas') {
                currentEntregadaIds = nuevosIds;
            }
        }

        // --- Carga de Pendientes ---
        async function cargarPendientes() {
            const { data: solicitudes } = await supabase
                .from("solicitudes")
                .select("*")
                .eq("estado", "Pendiente")
                .order("id", { ascending: false });

            // Obtener materiales para todas las solicitudes
            for (const s of solicitudes) {
                const { data: materiales } = await supabase
                    .from("materiales_solicitados")
                    .select("*")
                    .eq("id_solicitud", s.id);
                s.materiales = materiales;
            }
            
            // Usar la función de actualización inteligente
            actualizarContenedor("listaPendientes", solicitudes, crearCardPendiente, currentPendingIds);
        }

        // --- Carga de Entregadas (con lógica para preservar foco) ---
        async function cargarEntregadas() {
            // 1. Identificar el elemento que tiene el foco (antes de cualquier cambio)
            let focusedElementId = document.activeElement && document.activeElement.tagName === 'TEXTAREA' ? document.activeElement.id : null;

            // 2. Obtener los nuevos datos de Supabase
            const { data: solicitudes } = await supabase
                .from("solicitudes")
                .select("*")
                .eq("estado", "Entregado")
                .is("comentario_entrega", null)
                .order("id", { ascending: false });

            // Obtener materiales para todas las solicitudes
            for (const s of solicitudes) {
                const { data: materiales } = await supabase
                    .from("materiales_solicitados")
                    .select("*")
                    .eq("id_solicitud", s.id);
                s.materiales = materiales;
            }

            // 3. Usar la función de actualización inteligente
            // Esta función reusa los elementos <div> existentes, preservando el textarea.value
            actualizarContenedor("listaEntregadas", solicitudes, crearCardEntregada, currentEntregadaIds);

            // 4. Restaurar el foco en el elemento que estaba siendo editado
            if (focusedElementId) {
                const restoredFocusElement = document.getElementById(focusedElementId);
                if (restoredFocusElement) {
                    restoredFocusElement.focus();
                    
                    // Opcional: Mover el cursor al final del texto para una mejor experiencia de escritura
                    const currentLength = restoredFocusElement.value.length;
                    restoredFocusElement.setSelectionRange(currentLength, currentLength);
                }
            }
        }

        async function cargarTodo() {
            // Se utiliza Promise.all para que ambas cargas se hagan en paralelo
            await Promise.all([cargarPendientes(), cargarEntregadas()]);
        }

        // =============================
        //  FUNCIONES DE COMENTARIO
        // ... (sin cambios)
        // =============================
        window.guardarComentario = async function(id) {
            const txt = document.getElementById(`coment_${id}`).value.trim();
            if (!txt) return alert("Escribe un comentario primero.");
            await supabase
                .from("solicitudes")
                .update({ comentario_entrega: txt })
                .eq("id", id);
            cargarTodo();
        }

        window.guardarSinComentario = async function(id) {
            await supabase
                .from("solicitudes")
                .update({ comentario_entrega: "Sin comentario" })
                .eq("id", id);
            cargarTodo();
        }

        // =============================
        //   AUTO-ACTUALIZACIÓN 5s
        // =============================
        cargarTodo();
        setInterval(cargarTodo, 5000);

    }); // fin DOMContentLoaded
</script>
